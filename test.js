var test = require('tape')
var parse = require('esprima').parse
var walk = require('./')

var MOD = { sourceType: 'module' }

function steps (node) {
  console.log(node.type)
  return walk.step(node, []) !== null
}

test('walk nodes', function (t) {
  t.plan(57) // 60 total
  t.true(steps(parse('123')), 'walk Program')
  t.true(steps(parse('class Foo{}').body[0].body), 'walk ClassBody')
  t.true(steps(parse('if (true) {foo(); bar()}').body[0].consequent), 'walk BlockStatement')
  t.true(steps(parse('let [x] = foo').body[0].declarations[0].id), 'walk ArrayPattern')
  t.true(steps(parse('[1, 2, 3]').body[0].expression), 'walk ArrayExpression')
  t.true(steps(parse('let {x} = foo').body[0].declarations[0].id), 'walk ObjectPattern')
  t.true(steps(parse('({foo:1})').body[0].expression), 'walk ObjectExpression')
  t.true(steps(parse('if (x) bar()').body[0].consequent), 'walk ExpressionStatement')
  t.true(steps(parse('with (foo) {}').body[0]), 'walk WithStatement')
  t.true(steps(parse('function foo() {return 1}').body[0].body.body[0]), 'walk ReturnStatement')
  t.true(steps(parse('foo: while(x) bar()').body[0]), 'walk LabeledStatement')
  t.true(steps(parse('foo: while(x) break foo').body[0].body.body), 'walk BreakStatement')
  t.true(steps(parse('foo: while(x) continue foo').body[0].body.body), 'walk ContinueStatement')
  t.true(steps(parse('if (foo) bar()').body[0]), 'walk IfStatement')
  t.true(steps(parse('!foo').body[0].expression), 'walks UnaryOperator')
  t.true(steps(parse('foo--').body[0].expression), 'walk UpdateExpression')
  t.true(steps(parse('function* foo() {yield 1}').body[0].body.body[0].expression), 'walk YieldExpression')
  t.true(steps(parse('function foo(...bar) {}').body[0].params[0]), 'walk RestElement')
  t.true(steps(parse('[...foo]').body[0].expression.elements[0]), 'walk SpreadElement')
  t.true(steps(parse('try {throw 1} catch(e) {}').body[0].block.body[0]), 'walk ThrowExpression')
  t.true(steps(parse('(class {})').body[0].expression), 'walk ClassExpression')
  t.true(steps(parse('try {} catch(e) {foo()}').body[0].handler), 'walk CatchClause')
  t.true(steps(parse('while (true) {}').body[0]), 'walks WhileStatement')
  t.true(steps(parse('do {} while(foo)').body[0]), 'walk DoWhileStatement')
  t.true(steps(parse('for(var i of bar) bar()').body[0]), 'walks ForOfStatement')
  t.true(steps(parse('for(var i in bar) bar()').body[0]), 'walks ForInStatement')
  t.true(steps(parse('var i = 1').body[0]), 'walks VariableDeclaration')
  t.true(steps(parse('foo || bar').body[0].expression), 'walks LogicalExpression')
  t.true(steps(parse('function a (b = 1) {}').body[0].params[0]), 'walks AssignmentPattern')
  t.true(steps(parse('(foo = 1)').body[0].expression), 'walks AssignmentExpression')
  t.true(steps(parse('1 + 2').body[0].expression), 'walks BinaryExpression')
  t.true(steps(parse('foo[bar]').body[0].expression), 'walks MemberExpression')
  t.true(steps(parse('foo ? bar : baz').body[0].expression), 'walks ConditionalExpression')
  t.true(steps(parse('var foo, bar; foo = 1, bar = 2').body[1].expression), 'walks SequenceExpression')
  t.true(steps(parse('foo`bar`').body[0].expression), 'walks TaggedTemplateExpression')
  // t.true(steps(parse('const {x, y} = bar').body[0]), 'walks AssignmentProperty')
  t.true(steps(parse('class Foo{bar(){}}').body[0].body.body[0]), 'walks MethodDefinition')
  // t.true(steps(parse('')), 'walks MetaProperty')
  t.true(steps(parse('import foo from "bar"', MOD).body[0].specifiers[0]), 'walks ImportDefaultSpecifier')
  t.true(steps(parse('import * as foo from "bar"', MOD).body[0].specifiers[0]), 'walks ImportNamespaceSpecifier')
  t.true(steps(parse('import {foo} from "bar"', MOD).body[0].specifiers[0]), 'walks ImportSpecifier')
  t.true(steps(parse('var foo = 1; export {foo}', MOD).body[1].specifiers[0]), 'walks ExportSpecifier')
  t.true(steps(parse('export default 1', MOD).body[0]), 'walks ExportDefaultDeclaration')
  t.true(steps(parse('export * from "bar"', MOD).body[0]), 'walks ExportAllDeclaration')
  t.true(steps(parse('for (var a=10;a;a--) {}').body[0]), 'walks ForStatement')
  t.true(steps(parse('try {} catch (e) {}').body[0]), 'walks TryStatement')
  t.true(steps(parse('switch (e) {}').body[0]), 'walks SwitchStatement')
  t.true(steps(parse('switch(e){case 123:{bar();break}}').body[0].cases[0]), 'walks SwitchCase')
  // console.log()
  t.true(steps(parse('({set foo (e) {}})').body[0].expression.properties[0]), 'walks Property')
  t.true(steps(parse('`foo${"bar"}baz`').body[0].expression), 'walks TemplateLiteral')
  // t.true(steps(parse('')), 'walks Function')
  t.true(steps(parse('(function () {})').body[0].expression), 'walks FunctionExpression')
  t.true(steps(parse('(() => 123)').body[0].expression), 'walks ArrowFunctionExpression')
  t.true(steps(parse('function foo (a, b) {}').body[0]), 'walks FunctionDeclaration')
  t.true(steps(parse('new Foo()').body[0].expression), 'walks NewExpression')
  t.true(steps(parse('foo(1, 2)').body[0].expression), 'walks CallExpression')
  t.true(steps(parse('(class {})').body[0].expression), 'walks ClassExpression')
  t.true(steps(parse('import foo from "bar"', MOD).body[0]), 'walks ImportDeclaration')
  t.true(steps(parse('export {foo, bar}', MOD).body[0]), 'walks ExportNamedDeclaration')
  t.true(steps(parse('class Foo{}').body[0]), 'walk ClassDeclaration')
  // t.true(steps(parse('')), 'walks ')
  t.end()
})

test('doesnt walk nodes', function (t) {
  t.plan(1)
  t.false(steps(parse('123').body[0].expression), 'does not walk Literal')
  // t.false(steps(parse('')), 'does not walk ')
  t.end()
})
